-->Werkzeug module-:
The werkzeug.security module is a built-in security utility provided by Werkzeug, which is a core dependency of Flask.
üîê What is werkzeug.security?
It is a submodule of Werkzeug, and it provides simple and secure functions for:
->Hashing passwords
->Verifying hashed passwords
These are essential for any Flask application that handles user authentication.

1. generate_password_hash(password)
Purpose: Securely hashes a plain-text password.

Usage:

from werkzeug.security import generate_password_hash

hash = generate_password_hash("mysecretpassword")
Behind the scenes: It uses PBKDF2, a strong hashing algorithm, with a salt and multiple iterations.

2. check_password_hash(hash, password)
Purpose: Verifies whether the entered password matches the stored hash.

Usage:
from werkzeug.security import check_password_hash

check_password_hash(hash, "mysecretpassword")  # Returns True or False


//werkzeug.security hashes the password using a strong algorithm that:
->Cannot be easily reversed
->Adds a random salt automatically
->Is safe against brute-force attacks



üîê Password Handling Methods

    def set_password(self, password):
        self.password_hash = generate_password_hash(password)
->This helper method takes a plain text password and:
->Uses generate_password_hash() to securely hash it.
->Saves it to the password_hash field.

    def check_password(self, password):
        return check_password_hash(self.password_hash, password)
->This method checks whether a given password is correct.
->Takes user input (password) and compares it to the stored hash

 Example Usage:

# Creating a user
user = User(username='pawan', email='pawan@example.com')
user.set_password('mysecretpassword')
db.session.add(user)
db.session.commit()

# Checking password
user.check_password('wrongpass')  # ‚ùå False
user.check_password('mysecretpassword')  # ‚úÖ True



üß† What is UserMixin?
UserMixin is a helper class from Flask-Login that automatically adds required methods to your User model so 
Flask-Login can work properly.

It adds methods like:
is_authenticated ‚Üí Returns True if the user is authenticated
is_active ‚Üí Returns True if the user is active
is_anonymous ‚Üí Returns False for real users
get_id() ‚Üí Returns the user‚Äôs ID (as a string)

üîç Why you don‚Äôt call these methods yourself
You don‚Äôt call these methods directly in your code, but Flask-Login does!
For example:
from flask_login import login_user
login_user(user)
Behind the scenes, Flask-Login will internally use:
user.is_authenticated
user.get_id()
etc.

You don‚Äôt have to define or call those yourself ‚Äî UserMixin provides them so Flask-Login can recognize your 
model as a valid "user".


# Relationships in User Model-:
    portfolio = db.relationship('Portfolio', backref='owner', lazy=True)
    transactions = db.relationship('Transaction', backref='owner', lazy=True)
db.relationship(...) does not create DB columns. It creates Python attributes for convenient access to related rows.
'Portfolio' and 'Transaction' are the target model names (strings so order doesn't matter).
backref='owner' creates a complementary attribute on the child model (so a_portfolio.owner returns the User object).
lazy=True controls loading strategy: with lazy=True (Flask-SQLAlchemy accepts this shorthand), SQLAlchemy will load related items on access with a separate SELECT (i.e., lazy-loading).
(Other common values: 'select', 'joined', 'subquery', 'dynamic'.)

After these relationships you can do:
user.portfolio ‚Üí list of Portfolio rows for that user.
user.transactions ‚Üí list of Transaction rows for that user.
portfolio.owner ‚Üí that portfolio‚Äôs User instance (thanks to backref).




1Ô∏è‚É£ Portfolio Model
Tracks the user‚Äôs holdings.
Fields to include:
id ‚Üí Primary key
user_id ‚Üí Foreign key linking to the User table
symbol ‚Üí Stock/Crypto symbol (e.g., "AAPL", "BTC")
quantity ‚Üí How many units the user owns
avg_price ‚Üí Average price at which they bought
created_at / updated_at ‚Üí Track changes


Portfolio model-:

class Portfolio(db.Model):
    id = db.Column(db.Integer, primary_key=True)
Table for holding holdings per user ‚Äî id is the primary key.


    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
user_id is a foreign key referencing user.id (the User table‚Äôs id column).
The string 'user.id' uses default table naming (SQLAlchemy uses the lowercased class name 'user' 
by default unless you set __tablename__).nullable=False means every portfolio row must be attached to a user.


    symbol = db.Column(db.String(10), nullable=False)
Symbol/ticker for the asset (e.g., 'AAPL', 'BTC') limited to 10 characters. Non-nullable.


    quantity = db.Column(db.Float, nullable=False, default=0.0)
How many units of the asset the user holds.
Float datatype.
default=0.0 means if no value is provided when inserting, DB/SQLAlchemy uses 0.0.

    avg_price = db.Column(db.Float, nullable=False, default=0.0)
Average price paid per unit (useful for calculating unrealized P/L). Non-nullable, default 0.0.

    created_at = db.Column(db.DateTime, default=lambda:datetime.now(timezone.utc))
When the row was created.

    updated_at = db.Column(db.DateTime, default=lambda:datetime.now(timezone.utc), onupdate=lambda:datetime.now(timezone.utc))
updated_at stores last modification time.
default=datetime.now(timezone.utc) sets initial value.
onupdate=lambda:datetime.now(timezone.utc) instructs SQLAlchemy to set this column to current UTC time automatically whenever the row is updated.





2Ô∏è‚É£ Transaction Model
Logs every buy/sell action so we can show history.
Fields to include:
id ‚Üí Primary key
user_id ‚Üí Foreign key linking to the User table
symbol ‚Üí Stock/Crypto symbol
quantity ‚Üí Number of units bought or sold
price ‚Üí Price per unit during transaction
transaction_type ‚Üí Either "BUY" or "SELL"
timestamp ‚Üí When the transaction happened


Transaction model-:

class Transaction(db.Model):
    id = db.Column(db.Integer, primary_key=True)
Primary key for transactions.

    user_id = db.Column(db.Integer, db.ForeignKey('user.id'), nullable=False)
Foreign key linking the transaction to the User. Every transaction belongs to a user.


    symbol = db.Column(db.String(10), nullable=False)
The traded asset symbol.


    quantity = db.Column(db.Float, nullable=False)
Quantity bought/sold ‚Äî non-nullable.


    price = db.Column(db.Float, nullable=False)
Trade price per unit (or total price depending on your design). Non-nullable.


    transaction_type = db.Column(db.String(4), nullable=False)  # BUY or SELL
Short code to indicate trade type. Length 4 is enough for 'BUY' or 'SELL'.

Non-nullable. You might consider an Enum type to restrict allowed values ('BUY'/'SELL') if you want stricter validation at DB level.

    timestamp = db.Column(db.DateTime, default=datetime.utcnow)
When the transaction happened. Default is current UTC timestamp at insert.
