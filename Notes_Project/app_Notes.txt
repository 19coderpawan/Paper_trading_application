from flask import Flask
✅ What it does:
Imports the core Flask class from the Flask library.
You'll use this to create your Flask app instance.


from flask_sqlalchemy import SQLAlchemy
✅ What it does:
Imports SQLAlchemy, the Flask extension that integrates SQLAlchemy ORM with Flask.


from instance.config import Config
✅ What it does:
Imports the Config class from instance/config.py.
This class (as discussed earlier) loads sensitive config like SECRET_KEY, database URI, etc. — usually using .env.

db = SQLAlchemy()
✅ What it does:
Creates a SQLAlchemy object — not tied to any app yet.


def create_app():
✅ What it does:
Defines a function that creates and configures your Flask app.
This is useful for separating app creation and configuration, especially for testing, modularity, or multiple environments.


    app = Flask(__name__)
✅ What it does:
Creates the actual Flask application instance.
__name__ helps Flask locate your templates and static files.

    app.config.from_object(Config)
✅ What it does:
Loads configuration from the imported Config class (from instance/config.py).

This sets values like:
SECRET_KEY
SQLALCHEMY_DATABASE_URI


    db.init_app(app)
✅ What it does:
Initializes the SQLAlchemy extension with your Flask app.

This binds the earlier db = SQLAlchemy() object to the app.


    from models import User, Trade
✅ What it does:
Imports your models after db is initialized.
This ensures that models use the correct db context.


    with app.app_context():
        db.create_all()
✅ What it does:
Creates the tables in your database only if they don’t exist already.
app.app_context() sets the current app context (needed when working outside a route).
db.create_all() creates the schema from the models.


    from routes import main
✅ What it does:
Imports the main Blueprint from routes.py .

Using Blueprints is a good practice for organizing routes cleanly, especially in larger apps.

    app.register_blueprint(main)
✅ What it does:
Registers the main blueprint so that the routes defined in it are available to the app.


    return app
✅ What it does:
Returns the fully created and configured Flask app.

 Summary of What Happens
When create_app() is called:
->A Flask app is created.
->Config is loaded (including from .env).
->Database is initialized.
->Tables (User, Trade) are created if missing.
->Routes are registered using a blueprint.
->Final app is returned.
->This pattern is powerful and used by production-ready Flask apps.



 What is a Blueprint in Flask?
A Blueprint in Flask is a way to organize your application into modular components.

Instead of putting all routes in app.py, you separate them into different files or sections using Blueprints.

 Why Use Blueprints Instead of Direct Routes?
Yes, you can write routes directly in app.py, like this:

@app.route('/')
def home():
    return 'Hello'
But that becomes messy very fast as your app grows. Imagine you have:
-->Auth routes (/login, /register)
-->Dashboard routes
-->Trading routes
-->Admin routes
-->API endpoints

A Blueprint in Flask is like a template for a group of routes, forms, or logic that you want to add to your app.
-> Think of a blueprint like a modular mini-app inside your main app.

When you register_blueprint(), you are telling Flask:
->“Hey, I have this set of routes and logic defined in a blueprint — please attach it to the main app so it 
   actually works.”



*****LoginManager: From Flask-Login, used to manage user sessions (logins, logouts, etc.).*****  
🧠 What is Flask-Login and LoginManager?
Flask-Login helps you manage user authentication and session handling in your app:
Keeps track of logged-in users.
Redirects users to the login page if they try to access protected routes.
Remembers the user session across requests.
LoginManager is the main controller for Flask-Login — you configure it with your app and define how it should behave. 

🔐 LoginManager configuration

    login_manager.login_view = 'auth.login'
    login_manager.login_message_category = 'info'

login_view = 'auth.login':
This tells Flask-Login which view (route) to redirect unauthenticated users to
auth.login means: login() function in the auth blueprint.

login_message_category = 'info':
If user is redirected, a message like “Please log in to access this page” is flashed.
This sets the flash category (info, success, danger, etc.) for styling in templates


👤 Load user function

    from models import User
    @login_manager.user_loader
    def load_user(user_id):
        return User.query.get(int(user_id))
This is essential for Flask-Login to work.
When a user logs in, Flask-Login stores their user_id in the session.
On each request, Flask-Login calls this load_user() function with the user_id.
Your function queries the database to retrieve the full User object.
This object becomes current_user in your templates and views.